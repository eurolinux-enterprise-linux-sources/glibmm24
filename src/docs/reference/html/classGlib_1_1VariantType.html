<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>glibmm: Glib::VariantType Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.56.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGlib.html">Glib</a></li><li class="navelem"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classGlib_1_1VariantType-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Glib::VariantType Class Reference<div class="ingroups"><a class="el" href="group__Variant.html">Variant Data Types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a> - The <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a> type system.  
 <a href="classGlib_1_1VariantType.html#details">More...</a></p>

<p><code>#include &lt;glibmm/varianttype.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7d05abfd748f0e5917996682eb8d7b3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a7d05abfd748f0e5917996682eb8d7b3f">VariantType</a> ()</td></tr>
<tr class="memdesc:a7d05abfd748f0e5917996682eb8d7b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an invalid object.  <a href="#a7d05abfd748f0e5917996682eb8d7b3f">More...</a><br /></td></tr>
<tr class="separator:a7d05abfd748f0e5917996682eb8d7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f6a6269718a433540a56b874dd9e93"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#aa9f6a6269718a433540a56b874dd9e93">VariantType</a> (GVariantType* castitem, bool make_a_copy=false)</td></tr>
<tr class="separator:aa9f6a6269718a433540a56b874dd9e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfa490c6545d0b0a3af409a1890c5b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#addfa490c6545d0b0a3af409a1890c5b3">VariantType</a> (const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp; src)</td></tr>
<tr class="separator:addfa490c6545d0b0a3af409a1890c5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d63c3af32d9c2eeeeea3009207457fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a0d63c3af32d9c2eeeeea3009207457fe">operator=</a> (const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp; src)</td></tr>
<tr class="separator:a0d63c3af32d9c2eeeeea3009207457fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b75713e8127362005aae10aa3a1e96b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a9b75713e8127362005aae10aa3a1e96b">VariantType</a> (<a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&amp; other) noexcept</td></tr>
<tr class="separator:a9b75713e8127362005aae10aa3a1e96b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e8c7bc32e1cae7c8c7c4044f32e996"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a05e8c7bc32e1cae7c8c7c4044f32e996">operator=</a> (<a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&amp; other) noexcept</td></tr>
<tr class="separator:a05e8c7bc32e1cae7c8c7c4044f32e996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2e2b2fb55596457bf1de943d8a267e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#ade2e2b2fb55596457bf1de943d8a267e">~VariantType</a> () noexcept</td></tr>
<tr class="separator:ade2e2b2fb55596457bf1de943d8a267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7b5d84857755c4cc9f6dfec22ccfbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#aaa7b5d84857755c4cc9f6dfec22ccfbd">swap</a> (<a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp; other) noexcept</td></tr>
<tr class="separator:aaa7b5d84857755c4cc9f6dfec22ccfbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911a3cfa7c4fc5e56cca07f0cb765487"><td class="memItemLeft" align="right" valign="top">GVariantType*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a911a3cfa7c4fc5e56cca07f0cb765487">gobj</a> ()</td></tr>
<tr class="separator:a911a3cfa7c4fc5e56cca07f0cb765487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe52b6c2db8a92fa44b6fe0f06a3dc8e"><td class="memItemLeft" align="right" valign="top">const GVariantType*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#afe52b6c2db8a92fa44b6fe0f06a3dc8e">gobj</a> () const</td></tr>
<tr class="separator:afe52b6c2db8a92fa44b6fe0f06a3dc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5c6f3b59411bbd3fd73b3df561d34a"><td class="memItemLeft" align="right" valign="top">GVariantType*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a4d5c6f3b59411bbd3fd73b3df561d34a">gobj_copy</a> () const</td></tr>
<tr class="memdesc:a4d5c6f3b59411bbd3fd73b3df561d34a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for freeing it. Use when directly setting fields in structs.  <a href="#a4d5c6f3b59411bbd3fd73b3df561d34a">More...</a><br /></td></tr>
<tr class="separator:a4d5c6f3b59411bbd3fd73b3df561d34a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02bb61ceab7e1b8f89c2cbcd39e01de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#af02bb61ceab7e1b8f89c2cbcd39e01de">VariantType</a> (const GVariantType* castitem)</td></tr>
<tr class="memdesc:af02bb61ceab7e1b8f89c2cbcd39e01de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the C item into a new <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a> instance.  <a href="#af02bb61ceab7e1b8f89c2cbcd39e01de">More...</a><br /></td></tr>
<tr class="separator:af02bb61ceab7e1b8f89c2cbcd39e01de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10ea525df2b241b59036de7684ae565"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#ae10ea525df2b241b59036de7684ae565">VariantType</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; type_string)</td></tr>
<tr class="memdesc:ae10ea525df2b241b59036de7684ae565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a> corresponding to the type string given by <em>type_string</em>.  <a href="#ae10ea525df2b241b59036de7684ae565">More...</a><br /></td></tr>
<tr class="separator:ae10ea525df2b241b59036de7684ae565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d8cf9c965f307b1dbabf5d8845e22a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a32d8cf9c965f307b1dbabf5d8845e22a">operator=</a> (const GVariantType* castitem)</td></tr>
<tr class="separator:a32d8cf9c965f307b1dbabf5d8845e22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fa954d836c05fa9f379feccb992cc8"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a19fa954d836c05fa9f379feccb992cc8">get_string</a> () const</td></tr>
<tr class="memdesc:a19fa954d836c05fa9f379feccb992cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type string corresponding to the given <em>type</em>.  <a href="#a19fa954d836c05fa9f379feccb992cc8">More...</a><br /></td></tr>
<tr class="separator:a19fa954d836c05fa9f379feccb992cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab508d0a43ced88c4beb685cda233d749"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#ab508d0a43ced88c4beb685cda233d749">is_definite</a> () const</td></tr>
<tr class="memdesc:ab508d0a43ced88c4beb685cda233d749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given <em>type</em> is definite (ie: not indefinite).  <a href="#ab508d0a43ced88c4beb685cda233d749">More...</a><br /></td></tr>
<tr class="separator:ab508d0a43ced88c4beb685cda233d749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409d35a4aea3e0c980c49c1e435ecade"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a409d35a4aea3e0c980c49c1e435ecade">is_container</a> () const</td></tr>
<tr class="memdesc:a409d35a4aea3e0c980c49c1e435ecade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given <em>type</em> is a container type.  <a href="#a409d35a4aea3e0c980c49c1e435ecade">More...</a><br /></td></tr>
<tr class="separator:a409d35a4aea3e0c980c49c1e435ecade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2422a87bb2ab461f5c82f0079a71af0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a2422a87bb2ab461f5c82f0079a71af0b">is_basic</a> () const</td></tr>
<tr class="memdesc:a2422a87bb2ab461f5c82f0079a71af0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given <em>type</em> is a basic type.  <a href="#a2422a87bb2ab461f5c82f0079a71af0b">More...</a><br /></td></tr>
<tr class="separator:a2422a87bb2ab461f5c82f0079a71af0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41070e6892073b6ce7f7ab7a93fe4c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#ad41070e6892073b6ce7f7ab7a93fe4c7">is_maybe</a> () const</td></tr>
<tr class="memdesc:ad41070e6892073b6ce7f7ab7a93fe4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given <em>type</em> is a maybe type.  <a href="#ad41070e6892073b6ce7f7ab7a93fe4c7">More...</a><br /></td></tr>
<tr class="separator:ad41070e6892073b6ce7f7ab7a93fe4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a5ba87ca42a8e4d5a7309379057f2aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a9a5ba87ca42a8e4d5a7309379057f2aa">is_array</a> () const</td></tr>
<tr class="memdesc:a9a5ba87ca42a8e4d5a7309379057f2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given <em>type</em> is an array type.  <a href="#a9a5ba87ca42a8e4d5a7309379057f2aa">More...</a><br /></td></tr>
<tr class="separator:a9a5ba87ca42a8e4d5a7309379057f2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb484e023a8949a4f198560da28d4ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a5fb484e023a8949a4f198560da28d4ed">is_tuple</a> () const</td></tr>
<tr class="memdesc:a5fb484e023a8949a4f198560da28d4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given <em>type</em> is a tuple type.  <a href="#a5fb484e023a8949a4f198560da28d4ed">More...</a><br /></td></tr>
<tr class="separator:a5fb484e023a8949a4f198560da28d4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c90a1f8431c48806568a207c994c28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a26c90a1f8431c48806568a207c994c28">is_dict_entry</a> () const</td></tr>
<tr class="memdesc:a26c90a1f8431c48806568a207c994c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given <em>type</em> is a dictionary entry type.  <a href="#a26c90a1f8431c48806568a207c994c28">More...</a><br /></td></tr>
<tr class="separator:a26c90a1f8431c48806568a207c994c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadba2be4ad172a9e5ba984f02f4b54a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#aadba2be4ad172a9e5ba984f02f4b54a4">is_variant</a> () const</td></tr>
<tr class="memdesc:aadba2be4ad172a9e5ba984f02f4b54a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the given <em>type</em> is the variant type.  <a href="#aadba2be4ad172a9e5ba984f02f4b54a4">More...</a><br /></td></tr>
<tr class="separator:aadba2be4ad172a9e5ba984f02f4b54a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bc74a9d194766172ca1d90ec83cd50"><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a30bc74a9d194766172ca1d90ec83cd50">hash</a> () const</td></tr>
<tr class="memdesc:a30bc74a9d194766172ca1d90ec83cd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes <em>type</em>.  <a href="#a30bc74a9d194766172ca1d90ec83cd50">More...</a><br /></td></tr>
<tr class="separator:a30bc74a9d194766172ca1d90ec83cd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e6ca681dd0213162bdf68c61d000b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a22e6ca681dd0213162bdf68c61d000b3">equal</a> (const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp; other) const</td></tr>
<tr class="memdesc:a22e6ca681dd0213162bdf68c61d000b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares <em>*this</em> and <em>other</em> for equality.  <a href="#a22e6ca681dd0213162bdf68c61d000b3">More...</a><br /></td></tr>
<tr class="separator:a22e6ca681dd0213162bdf68c61d000b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc31e57323ada2fe326de577ac1c4d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a5cc31e57323ada2fe326de577ac1c4d0">is_subtype_of</a> (const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp; supertype) const</td></tr>
<tr class="memdesc:a5cc31e57323ada2fe326de577ac1c4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <em>type</em> is a subtype of <em>supertype</em>.  <a href="#a5cc31e57323ada2fe326de577ac1c4d0">More...</a><br /></td></tr>
<tr class="separator:a5cc31e57323ada2fe326de577ac1c4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b511f8318ab438cfa4edac75f576e35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a9b511f8318ab438cfa4edac75f576e35">element</a> () const</td></tr>
<tr class="memdesc:a9b511f8318ab438cfa4edac75f576e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the element type of an array or maybe type.  <a href="#a9b511f8318ab438cfa4edac75f576e35">More...</a><br /></td></tr>
<tr class="separator:a9b511f8318ab438cfa4edac75f576e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba77745f518e18ebe0a7cc1e877d581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a7ba77745f518e18ebe0a7cc1e877d581">first</a> () const</td></tr>
<tr class="memdesc:a7ba77745f518e18ebe0a7cc1e877d581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the first item type of a tuple or dictionary entry type.  <a href="#a7ba77745f518e18ebe0a7cc1e877d581">More...</a><br /></td></tr>
<tr class="separator:a7ba77745f518e18ebe0a7cc1e877d581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0d724fe4a290e41f6267c7cecb2e556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#aa0d724fe4a290e41f6267c7cecb2e556">next</a> () const</td></tr>
<tr class="memdesc:aa0d724fe4a290e41f6267c7cecb2e556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the next item type of a tuple or dictionary entry type.  <a href="#aa0d724fe4a290e41f6267c7cecb2e556">More...</a><br /></td></tr>
<tr class="separator:aa0d724fe4a290e41f6267c7cecb2e556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026696d44c063e742fef7df4776fe57f"><td class="memItemLeft" align="right" valign="top">gsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a026696d44c063e742fef7df4776fe57f">n_items</a> () const</td></tr>
<tr class="memdesc:a026696d44c063e742fef7df4776fe57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of items contained in a tuple or dictionary entry type.  <a href="#a026696d44c063e742fef7df4776fe57f">More...</a><br /></td></tr>
<tr class="separator:a026696d44c063e742fef7df4776fe57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e75517a29b17e483c641dacd6c68ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#af2e75517a29b17e483c641dacd6c68ff">key</a> () const</td></tr>
<tr class="memdesc:af2e75517a29b17e483c641dacd6c68ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the key type of a dictionary entry type.  <a href="#af2e75517a29b17e483c641dacd6c68ff">More...</a><br /></td></tr>
<tr class="separator:af2e75517a29b17e483c641dacd6c68ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4dfb79358c208eddea5086c01c58a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a8d4dfb79358c208eddea5086c01c58a8">value</a> () const</td></tr>
<tr class="memdesc:a8d4dfb79358c208eddea5086c01c58a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the value type of a dictionary entry type.  <a href="#a8d4dfb79358c208eddea5086c01c58a8">More...</a><br /></td></tr>
<tr class="separator:a8d4dfb79358c208eddea5086c01c58a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776ff2f8511d04f73596cac244a96857"><td class="memItemLeft" align="right" valign="top"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00965.html">std::vector</a>&lt; <a class="el" href="classGlib_1_1VariantType.html">VariantType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a776ff2f8511d04f73596cac244a96857">get_item_types</a> () const</td></tr>
<tr class="memdesc:a776ff2f8511d04f73596cac244a96857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the item types of a tuple or dictionary entry type.  <a href="#a776ff2f8511d04f73596cac244a96857">More...</a><br /></td></tr>
<tr class="separator:a776ff2f8511d04f73596cac244a96857"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a75cdb696a91c6fbc3cc9042bb20e66d0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a75cdb696a91c6fbc3cc9042bb20e66d0">create_array</a> (const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;<a class="el" href="classGlib_1_1VariantType.html#a9b511f8318ab438cfa4edac75f576e35">element</a>)</td></tr>
<tr class="memdesc:a75cdb696a91c6fbc3cc9042bb20e66d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the type corresponding to an array of elements of the type <em>type</em>.  <a href="#a75cdb696a91c6fbc3cc9042bb20e66d0">More...</a><br /></td></tr>
<tr class="separator:a75cdb696a91c6fbc3cc9042bb20e66d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac7660b174a80c9ae1ade6da36fac15"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#aeac7660b174a80c9ae1ade6da36fac15">create_maybe</a> (const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;<a class="el" href="classGlib_1_1VariantType.html#a9b511f8318ab438cfa4edac75f576e35">element</a>)</td></tr>
<tr class="memdesc:aeac7660b174a80c9ae1ade6da36fac15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the type corresponding to a maybe instance containing type <em>type</em> or Nothing.  <a href="#aeac7660b174a80c9ae1ade6da36fac15">More...</a><br /></td></tr>
<tr class="separator:aeac7660b174a80c9ae1ade6da36fac15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6ee0f41b29df3b43b548c267b0c16b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a1e6ee0f41b29df3b43b548c267b0c16b">create_tuple</a> (const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00965.html">std::vector</a>&lt; <a class="el" href="classGlib_1_1VariantType.html">VariantType</a> &gt;&amp; items)</td></tr>
<tr class="memdesc:a1e6ee0f41b29df3b43b548c267b0c16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a new tuple type, from <em>items</em>.  <a href="#a1e6ee0f41b29df3b43b548c267b0c16b">More...</a><br /></td></tr>
<tr class="separator:a1e6ee0f41b29df3b43b548c267b0c16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae491f86f5ebda97b1a6aae8cb96c6251"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#ae491f86f5ebda97b1a6aae8cb96c6251">create_dict_entry</a> (const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;<a class="el" href="classGlib_1_1VariantType.html#af2e75517a29b17e483c641dacd6c68ff">key</a>, const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;<a class="el" href="classGlib_1_1VariantType.html#a8d4dfb79358c208eddea5086c01c58a8">value</a>)</td></tr>
<tr class="memdesc:ae491f86f5ebda97b1a6aae8cb96c6251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the type corresponding to a dictionary entry with a key of type <em>key</em> and a value of type <em>value</em>.  <a href="#ae491f86f5ebda97b1a6aae8cb96c6251">More...</a><br /></td></tr>
<tr class="separator:ae491f86f5ebda97b1a6aae8cb96c6251"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9ca6d5b63454a54702ad5e890ec95d75"><td class="memItemLeft" align="right" valign="top">GVariantType*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a9ca6d5b63454a54702ad5e890ec95d75">gobject_</a></td></tr>
<tr class="separator:a9ca6d5b63454a54702ad5e890ec95d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a78bb154e5a13d78cd0d7a6bc6449d3c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a78bb154e5a13d78cd0d7a6bc6449d3c5">swap</a> (<a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp; lhs, <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp; rhs) noexcept</td></tr>
<tr class="separator:a78bb154e5a13d78cd0d7a6bc6449d3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab0237355a6c562fa30b3afc4a10332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantType.html#a7ab0237355a6c562fa30b3afc4a10332">wrap</a> (GVariantType* object, bool take_copy=false)</td></tr>
<tr class="memdesc:a7ab0237355a6c562fa30b3afc4a10332"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object.  <a href="#a7ab0237355a6c562fa30b3afc4a10332">More...</a><br /></td></tr>
<tr class="separator:a7ab0237355a6c562fa30b3afc4a10332"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a> - The <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a> type system. </p>
<p>The <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a> type system is based, in large part, on the D-Bus type system, with two major changes and some minor lifting of restrictions. <a href="http://dbus.freedesktop.org/doc/dbus-specification.html">The D-Bus specification</a>, therefore, provides a significant amount of information that is useful when working with <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a>.</p>
<p>The first major change with respect to the D-Bus type system is the introduction of maybe (or "nullable") types. Any type in <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a> can be converted to a maybe type, in which case, "nothing" (or "null") becomes a valid value. Maybe types have been added by introducing the character "m" to type strings.</p>
<p>The second major change is that the <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a> type system supports the concept of "indefinite types" &#8211; types that are less specific than the normal types found in D-Bus. For example, it is possible to speak of "an
array of any type" in <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a>, where the D-Bus type system would require you to speak of "an array of integers" or "an array of strings". Indefinite types have been added by introducing the characters "*", "?" and "r" to type strings.</p>
<p>Finally, all arbitrary restrictions relating to the complexity of types are lifted along with the restriction that dictionary entries may only appear nested inside of arrays.</p>
<p>Just as in D-Bus, <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a> types are described with strings ("type
strings"). Subject to the differences mentioned above, these strings are of the same form as those found in D-Bus. Note, however: D-Bus always works in terms of messages and therefore individual type strings appear nowhere in its interface. Instead, "signatures" are a concatenation of the strings of the type of each argument in a message. <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a> deals with single values directly so <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a> type strings always describe the type of exactly one value. This means that a D-Bus signature string is generally not a valid <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a> type string &#8211; except in the case that it is the signature of a message containing exactly one argument.</p>
<p>An indefinite type is similar in spirit to what may be called an abstract type in other type systems. No value can exist that has an indefinite type as its type, but values can exist that have types that are subtypes of indefinite types. That is to say, <a class="el" href="classGlib_1_1VariantBase.html#ad581febd10535aee8b71d2456f8351aa" title="Determines the type of value. ">VariantBase::get_type()</a> will never return an indefinite type, but calling <a class="el" href="classGlib_1_1VariantBase.html#a29f40905eddfb9c19bd1f2c143c08ce6" title="Checks if a value has a type matching the provided type. ">VariantBase::is_of_type()</a> with an indefinite type may return <code>true</code>. For example, you cannot have a value that represents "an array of no particular type", but you can have an "array of integers" which certainly matches the type of "an array of no
particular type", since "array of integers" is a subtype of "array of no
particular type".</p>
<p>This is similar to how instances of abstract classes may not directly exist in other type systems, but instances of their non-abstract subtypes may. For example, in gtkmm, no object that has the type of Gtk::Bin can exist (since Gtk::Bin is an abstract class), but a Gtk::Window can certainly be instantiated, and you would say that the Gtk::Window is a Gtk::Bin (since Gtk::Window is a subclass of Gtk::Bin).</p>
<p>See the underlying GVariantType documentation for <a href="http://library.gnome.org/devel/glib/unstable/glib-GVariantType.html#gvariant-typestrings">detailed description of the VariantBase type strings</a>.</p>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000059">Since glibmm 2.28:</a></b></dt><dd></dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7d05abfd748f0e5917996682eb8d7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d05abfd748f0e5917996682eb8d7b3f">&#9670;&#160;</a></span>VariantType() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantType::VariantType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an invalid object. </p>
<p>E.g. for output arguments to methods. There is not much you can do with the object before it has been assigned a valid value. </p>

</div>
</div>
<a id="aa9f6a6269718a433540a56b874dd9e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f6a6269718a433540a56b874dd9e93">&#9670;&#160;</a></span>VariantType() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantType::VariantType </td>
          <td>(</td>
          <td class="paramtype">GVariantType *&#160;</td>
          <td class="paramname"><em>castitem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_a_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="addfa490c6545d0b0a3af409a1890c5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfa490c6545d0b0a3af409a1890c5b3">&#9670;&#160;</a></span>VariantType() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantType::VariantType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b75713e8127362005aae10aa3a1e96b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b75713e8127362005aae10aa3a1e96b">&#9670;&#160;</a></span>VariantType() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantType::VariantType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade2e2b2fb55596457bf1de943d8a267e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2e2b2fb55596457bf1de943d8a267e">&#9670;&#160;</a></span>~VariantType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantType::~VariantType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af02bb61ceab7e1b8f89c2cbcd39e01de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02bb61ceab7e1b8f89c2cbcd39e01de">&#9670;&#160;</a></span>VariantType() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantType::VariantType </td>
          <td>(</td>
          <td class="paramtype">const GVariantType *&#160;</td>
          <td class="paramname"><em>castitem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy the C item into a new <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a> instance. </p>

</div>
</div>
<a id="ae10ea525df2b241b59036de7684ae565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10ea525df2b241b59036de7684ae565">&#9670;&#160;</a></span>VariantType() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantType::VariantType </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>type_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a> corresponding to the type string given by <em>type_string</em>. </p>
<p>It is a programmer error to call this function with an invalid type string. Use string_is_valid() if you are unsure. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a75cdb696a91c6fbc3cc9042bb20e66d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75cdb696a91c6fbc3cc9042bb20e66d0">&#9670;&#160;</a></span>create_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1VariantType.html">VariantType</a> Glib::VariantType::create_array </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the type corresponding to an array of elements of the type <em>type</em>. </p>
<p>It is appropriate to call g_variant_type_free() on the return value.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000024">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>A <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new array <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a>. </dd></dl>

</div>
</div>
<a id="ae491f86f5ebda97b1a6aae8cb96c6251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae491f86f5ebda97b1a6aae8cb96c6251">&#9670;&#160;</a></span>create_dict_entry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1VariantType.html">VariantType</a> Glib::VariantType::create_dict_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the type corresponding to a dictionary entry with a key of type <em>key</em> and a value of type <em>value</em>. </p>
<p>It is appropriate to call g_variant_type_free() on the return value.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000026">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>A basic <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a>. </td></tr>
    <tr><td class="paramname">value</td><td>A <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new dictionary entry <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a>. </dd></dl>

</div>
</div>
<a id="aeac7660b174a80c9ae1ade6da36fac15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac7660b174a80c9ae1ade6da36fac15">&#9670;&#160;</a></span>create_maybe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1VariantType.html">VariantType</a> Glib::VariantType::create_maybe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>element</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the type corresponding to a maybe instance containing type <em>type</em> or Nothing. </p>
<p>It is appropriate to call g_variant_type_free() on the return value.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000025">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">element</td><td>A <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new maybe <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a>. </dd></dl>

</div>
</div>
<a id="a1e6ee0f41b29df3b43b548c267b0c16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6ee0f41b29df3b43b548c267b0c16b">&#9670;&#160;</a></span>create_tuple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1VariantType.html">VariantType</a> Glib::VariantType::create_tuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00965.html">std::vector</a>&lt; <a class="el" href="classGlib_1_1VariantType.html">VariantType</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a new tuple type, from <em>items</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>A vector of VariantTypes, one for each item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new tuple <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a>.</dd></dl>
<dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000014">Since glibmm 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a9b511f8318ab438cfa4edac75f576e35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b511f8318ab438cfa4edac75f576e35">&#9670;&#160;</a></span>element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a> Glib::VariantType::element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the element type of an array or maybe type. </p>
<p>This function may only be used with array or maybe types.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000040">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The element type of <em>type</em>. </dd></dl>

</div>
</div>
<a id="a22e6ca681dd0213162bdf68c61d000b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e6ca681dd0213162bdf68c61d000b3">&#9670;&#160;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantType::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares <em>*this</em> and <em>other</em> for equality. </p>
<p>Only returns <code>true</code> if the types are exactly equal. Even if one type is an indefinite type and the other is a subtype of it, <code>false</code> will be returned if they are not exactly equal. If you want to check for subtypes, use <a class="el" href="classGlib_1_1VariantType.html#a5cc31e57323ada2fe326de577ac1c4d0" title="Checks if type is a subtype of supertype. ">is_subtype_of()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>*this</em> and <em>other</em> are exactly equal.</dd></dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000038">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a7ba77745f518e18ebe0a7cc1e877d581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba77745f518e18ebe0a7cc1e877d581">&#9670;&#160;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a> Glib::VariantType::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the first item type of a tuple or dictionary entry type. </p>
<p>This function may only be used with tuple or dictionary entry types, but must not be used with the generic tuple type G_VARIANT_TYPE_TUPLE.</p>
<p>In the case of a dictionary entry type, this returns the type of the key.</p>
<p><code>nullptr</code> is returned in case of <em>type</em> being G_VARIANT_TYPE_UNIT.</p>
<p>This call, together with g_variant_type_next() provides an iterator interface over tuple and dictionary entry types.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000041">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000062">Deprecated:</a></b></dt><dd>Use <a class="el" href="classGlib_1_1VariantType.html#a776ff2f8511d04f73596cac244a96857" title="Determines the item types of a tuple or dictionary entry type. ">get_item_types()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The first item type of <em>type</em>, or <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="a776ff2f8511d04f73596cac244a96857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776ff2f8511d04f73596cac244a96857">&#9670;&#160;</a></span>get_item_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00965.html">std::vector</a>&lt;<a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&gt; Glib::VariantType::get_item_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the item types of a tuple or dictionary entry type. </p>
<p>This function may only be used with tuple or dictionary entry types, but must not be used with the generic tuple type VARIANT_TYPE_TUPLE.</p>
<p>In the case of a dictionary entry type, returns a vector with 2 elements, the type of the key followed by the value type.</p>
<p>An empty vector is returned in case of this VariantType being VARIANT_TYPE_UNIT.</p>
<dl class="since_2_52"><dt><b><a class="el" href="since_2_52.html#_since_2_52000001">Since glibmm 2.52:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The item types of this VariantType, or an empty vector. </dd></dl>

</div>
</div>
<a id="a19fa954d836c05fa9f379feccb992cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fa954d836c05fa9f379feccb992cc8">&#9670;&#160;</a></span>get_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" doxygen="libstdc++.tag:http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Glib::VariantType::get_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type string corresponding to the given <em>type</em>. </p>
<p>The result is not nul-terminated; in order to determine its length you must call g_variant_type_get_string_length().</p>
<p>To get a nul-terminated string, see g_variant_type_dup_string().</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000028">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding type string (not nul-terminated). </dd></dl>

</div>
</div>
<a id="a911a3cfa7c4fc5e56cca07f0cb765487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911a3cfa7c4fc5e56cca07f0cb765487">&#9670;&#160;</a></span>gobj() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GVariantType* Glib::VariantType::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afe52b6c2db8a92fa44b6fe0f06a3dc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe52b6c2db8a92fa44b6fe0f06a3dc8e">&#9670;&#160;</a></span>gobj() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const GVariantType* Glib::VariantType::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d5c6f3b59411bbd3fd73b3df561d34a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5c6f3b59411bbd3fd73b3df561d34a">&#9670;&#160;</a></span>gobj_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GVariantType* Glib::VariantType::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for freeing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a id="a30bc74a9d194766172ca1d90ec83cd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30bc74a9d194766172ca1d90ec83cd50">&#9670;&#160;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint Glib::VariantType::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes <em>type</em>. </p>
<p>The argument type of <em>type</em> is only #gconstpointer to allow use with HashTable without function pointer casting. A valid <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a> must be provided.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000037">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The hash value. </dd></dl>

</div>
</div>
<a id="a9a5ba87ca42a8e4d5a7309379057f2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a5ba87ca42a8e4d5a7309379057f2aa">&#9670;&#160;</a></span>is_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantType::is_array </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given <em>type</em> is an array type. </p>
<p>This is true if the type string for <em>type</em> starts with an 'a'.</p>
<p>This function returns <code>true</code> for any indefinite type for which every definite subtype is an array type &#8211; G_VARIANT_TYPE_ARRAY, for example.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000033">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>type</em> is an array type. </dd></dl>

</div>
</div>
<a id="a2422a87bb2ab461f5c82f0079a71af0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2422a87bb2ab461f5c82f0079a71af0b">&#9670;&#160;</a></span>is_basic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantType::is_basic </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given <em>type</em> is a basic type. </p>
<p>Basic types are booleans, bytes, integers, doubles, strings, object paths and signatures.</p>
<p>Only a basic type may be used as the key of a dictionary entry.</p>
<p>This function returns <code>false</code> for all indefinite types except G_VARIANT_TYPE_BASIC.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000031">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>type</em> is a basic type. </dd></dl>

</div>
</div>
<a id="a409d35a4aea3e0c980c49c1e435ecade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a409d35a4aea3e0c980c49c1e435ecade">&#9670;&#160;</a></span>is_container()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantType::is_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given <em>type</em> is a container type. </p>
<p>Container types are any array, maybe, tuple, or dictionary entry types plus the variant type.</p>
<p>This function returns <code>true</code> for any indefinite type for which every definite subtype is a container &#8211; G_VARIANT_TYPE_ARRAY, for example.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000030">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>type</em> is a container type. </dd></dl>

</div>
</div>
<a id="ab508d0a43ced88c4beb685cda233d749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab508d0a43ced88c4beb685cda233d749">&#9670;&#160;</a></span>is_definite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantType::is_definite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given <em>type</em> is definite (ie: not indefinite). </p>
<p>A type is definite if its type string does not contain any indefinite type characters ('*', '?', or 'r').</p>
<p>A <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant&lt;&gt; classes. ">Variant</a> instance may not have an indefinite type, so calling this function on the result of g_variant_get_type() will always result in <code>true</code> being returned. Calling this function on an indefinite type like G_VARIANT_TYPE_ARRAY, however, will result in <code>false</code> being returned.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000029">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>type</em> is definite. </dd></dl>

</div>
</div>
<a id="a26c90a1f8431c48806568a207c994c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c90a1f8431c48806568a207c994c28">&#9670;&#160;</a></span>is_dict_entry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantType::is_dict_entry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given <em>type</em> is a dictionary entry type. </p>
<p>This is true if the type string for <em>type</em> starts with a '{'.</p>
<p>This function returns <code>true</code> for any indefinite type for which every definite subtype is a dictionary entry type &#8211; G_VARIANT_TYPE_DICT_ENTRY, for example.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000035">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>type</em> is a dictionary entry type. </dd></dl>

</div>
</div>
<a id="ad41070e6892073b6ce7f7ab7a93fe4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41070e6892073b6ce7f7ab7a93fe4c7">&#9670;&#160;</a></span>is_maybe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantType::is_maybe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given <em>type</em> is a maybe type. </p>
<p>This is true if the type string for <em>type</em> starts with an 'm'.</p>
<p>This function returns <code>true</code> for any indefinite type for which every definite subtype is a maybe type &#8211; G_VARIANT_TYPE_MAYBE, for example.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000032">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>type</em> is a maybe type. </dd></dl>

</div>
</div>
<a id="a5cc31e57323ada2fe326de577ac1c4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc31e57323ada2fe326de577ac1c4d0">&#9670;&#160;</a></span>is_subtype_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantType::is_subtype_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>supertype</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <em>type</em> is a subtype of <em>supertype</em>. </p>
<p>This function returns <code>true</code> if <em>type</em> is a subtype of <em>supertype</em>. All types are considered to be subtypes of themselves. Aside from that, only indefinite types can have subtypes.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000039">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">supertype</td><td>A <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>type</em> is a subtype of <em>supertype</em>. </dd></dl>

</div>
</div>
<a id="a5fb484e023a8949a4f198560da28d4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb484e023a8949a4f198560da28d4ed">&#9670;&#160;</a></span>is_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantType::is_tuple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given <em>type</em> is a tuple type. </p>
<p>This is true if the type string for <em>type</em> starts with a '(' or if <em>type</em> is G_VARIANT_TYPE_TUPLE.</p>
<p>This function returns <code>true</code> for any indefinite type for which every definite subtype is a tuple type &#8211; G_VARIANT_TYPE_TUPLE, for example.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000034">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>type</em> is a tuple type. </dd></dl>

</div>
</div>
<a id="aadba2be4ad172a9e5ba984f02f4b54a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadba2be4ad172a9e5ba984f02f4b54a4">&#9670;&#160;</a></span>is_variant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantType::is_variant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the given <em>type</em> is the variant type. </p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000036">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>type</em> is the variant type. </dd></dl>

</div>
</div>
<a id="af2e75517a29b17e483c641dacd6c68ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e75517a29b17e483c641dacd6c68ff">&#9670;&#160;</a></span>key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a> Glib::VariantType::key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the key type of a dictionary entry type. </p>
<p>This function may only be used with a dictionary entry type. Other than the additional restriction, this call is equivalent to g_variant_type_first().</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000044">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The key type of the dictionary entry. </dd></dl>

</div>
</div>
<a id="a026696d44c063e742fef7df4776fe57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026696d44c063e742fef7df4776fe57f">&#9670;&#160;</a></span>n_items()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsize Glib::VariantType::n_items </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the number of items contained in a tuple or dictionary entry type. </p>
<p>This function may only be used with tuple or dictionary entry types, but must not be used with the generic tuple type G_VARIANT_TYPE_TUPLE.</p>
<p>In the case of a dictionary entry type, this function will always return 2.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000043">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items in <em>type</em>. </dd></dl>

</div>
</div>
<a id="aa0d724fe4a290e41f6267c7cecb2e556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0d724fe4a290e41f6267c7cecb2e556">&#9670;&#160;</a></span>next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a> Glib::VariantType::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the next item type of a tuple or dictionary entry type. </p>
<p><em>type</em> must be the result of a previous call to g_variant_type_first() or g_variant_type_next().</p>
<p>If called on the key type of a dictionary entry then this call returns the value type. If called on the value type of a dictionary entry then this call returns <code>nullptr</code>.</p>
<p>For tuples, <code>nullptr</code> is returned when <em>type</em> is the last item in a tuple.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000042">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000063">Deprecated:</a></b></dt><dd>Use <a class="el" href="classGlib_1_1VariantType.html#a776ff2f8511d04f73596cac244a96857" title="Determines the item types of a tuple or dictionary entry type. ">get_item_types()</a> instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The next <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a> after <em>type</em>, or <code>nullptr</code>. </dd></dl>

</div>
</div>
<a id="a0d63c3af32d9c2eeeeea3009207457fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d63c3af32d9c2eeeeea3009207457fe">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp; Glib::VariantType::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05e8c7bc32e1cae7c8c7c4044f32e996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e8c7bc32e1cae7c8c7c4044f32e996">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp; Glib::VariantType::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32d8cf9c965f307b1dbabf5d8845e22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32d8cf9c965f307b1dbabf5d8845e22a">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp; Glib::VariantType::operator= </td>
          <td>(</td>
          <td class="paramtype">const GVariantType *&#160;</td>
          <td class="paramname"><em>castitem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa7b5d84857755c4cc9f6dfec22ccfbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7b5d84857755c4cc9f6dfec22ccfbd">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::VariantType::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d4dfb79358c208eddea5086c01c58a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4dfb79358c208eddea5086c01c58a8">&#9670;&#160;</a></span>value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a> Glib::VariantType::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the value type of a dictionary entry type. </p>
<p>This function may only be used with a dictionary entry type.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000045">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The value type of the dictionary entry. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a78bb154e5a13d78cd0d7a6bc6449d3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bb154e5a13d78cd0d7a6bc6449d3c5">&#9670;&#160;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ab0237355a6c562fa30b3afc4a10332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab0237355a6c562fa30b3afc4a10332">&#9670;&#160;</a></span>wrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantType.html">Glib::VariantType</a> wrap </td>
          <td>(</td>
          <td class="paramtype">GVariantType *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9ca6d5b63454a54702ad5e890ec95d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca6d5b63454a54702ad5e890ec95d75">&#9670;&#160;</a></span>gobject_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GVariantType* Glib::VariantType::gobject_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 31 2018 09:12:11 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
